var searchIndex = JSON.parse('{\
"dusk_plonk":{"doc":"                      ","i":[[0,"commitment_scheme","dusk_plonk","Ideally we should cleanly abstract away the polynomial…",null,null],[0,"kzg10","dusk_plonk::commitment_scheme","Implementation of the KZG10 polynomial commitment scheme.",null,null],[3,"Proof","dusk_plonk::commitment_scheme::kzg10","Proof that a polynomial `p` was correctly evaluated at a…",null,null],[12,"commitment_to_witness","","This is a commitment to the witness polynomial.",0,null],[12,"evaluated_point","","This is the result of evaluating a polynomial at the point…",0,null],[12,"commitment_to_polynomial","","This is the commitment to the polynomial that you want to…",0,null],[3,"AggregateProof","","Proof that multiple polynomials were correctly evaluated…",null,null],[12,"commitment_to_witness","","This is a commitment to the aggregated witness polynomial.",1,null],[12,"evaluated_points","","These are the results of the evaluating each polynomial at…",1,null],[12,"commitments_to_polynomials","","These are the commitments to the polynomials which you…",1,null],[3,"Commitment","","Holds a commitment to a polynomial in a form of a…",null,null],[12,"0","","The commitment is a group element.",2,null],[0,"errors","","Errors related to KZG10",null,null],[3,"PolyCommitSchemeError","dusk_plonk::commitment_scheme::kzg10::errors","Represents an error triggered on any of the Polynomial…",null,null],[4,"KZG10Errors","","Represents an error in the PublicParameters creation and…",null,null],[13,"DegreeIsZero","","This error occurs when the user tries to create…",3,null],[13,"TruncatedDegreeTooLarge","","This error occurs when the user tries to trim…",3,null],[13,"TruncatedDegreeIsZero","","This error occurs when the user tries to trim…",3,null],[13,"PolynomialDegreeTooLarge","","This error occurs when the user tries to commit to a…",3,null],[13,"PolynomialDegreeIsZero","","This error occurs when the user tries to commit to a…",3,null],[13,"PairingCheckFailure","","This error occurs when the pairing check fails at being…",3,null],[0,"key","dusk_plonk::commitment_scheme::kzg10","Key module contains the utilities and data structures that…",null,null],[3,"OpeningKey","dusk_plonk::commitment_scheme::kzg10::key","Opening Key is used to verify opening proofs made about a…",null,null],[12,"g","","The generator of G1.",4,null],[12,"h","","The generator of G2.",4,null],[12,"beta_h","","\\\\beta times the above generator of G2.",4,null],[12,"prepared_h","","The generator of G2, prepared for use in pairings.",4,null],[12,"prepared_beta_h","","\\\\beta times the above generator of G2, prepared for use in…",4,null],[3,"CommitKey","","CommitKey is used to commit to a polynomial which is…",null,null],[12,"powers_of_g","","Group elements of the form `{ \\\\beta^i G }`, where `i`…",5,null],[11,"max_degree","","Returns the maximum degree polynomial that you can commit…",5,[[]]],[11,"truncate","","Truncates the commit key to a lower max degree. Returns an…",5,[[],[["commitkey",3],["error",3],["result",4]]]],[11,"commit","","Commits to a polynomial returning the corresponding…",5,[[["polynomial",3]],[["commitment",3],["error",3],["result",4]]]],[11,"compute_single_witness","","For a given polynomial `p` and a point `z`, compute the…",5,[[["polynomial",3],["scalar",3]],["polynomial",3]]],[11,"open_single","","Creates an opening proof that a polynomial `p` was…",5,[[["polynomial",3],["scalar",3]],[["result",4],["error",3],["proof",3]]]],[11,"open_multiple","","Creates an opening proof that multiple polynomials were…",5,[[["vec",3],["transcript",3],["scalar",3],["scalar",3]],[["error",3],["aggregateproof",3],["result",4]]]],[11,"check","","Checks that a polynomial `p` was evaluated at a point `z`…",4,[[["scalar",3],["proof",3]]]],[11,"batch_check","","Checks whether a batch of polynomials evaluated at…",4,[[["transcript",3]],[["result",4],["error",3]]]],[0,"srs","dusk_plonk::commitment_scheme::kzg10","The Public Parameters can also be referred to as the…",null,null],[3,"PublicParameters","dusk_plonk::commitment_scheme::kzg10::srs","The Public Parameters can also be referred to as the…",null,null],[12,"commit_key","","Key used to generate proofs for composed circuits.",6,null],[12,"opening_key","","Key used to verify proofs for composed circuits.",6,null],[11,"setup","","Setup generates the public parameters using a random…",6,[[],[["error",3],["result",4],["publicparameters",3]]]],[11,"trim","","Trim truncates the prover key to allow the prover to…",6,[[],[["result",4],["error",3]]]],[11,"max_degree","","Max degree specifies the largest polynomial that this…",6,[[]]],[11,"with_witness","dusk_plonk::commitment_scheme::kzg10","Initialises an `AggregatedProof` with the commitment to…",1,[[["commitment",3]],["aggregateproof",3]]],[11,"add_part","","Adds an evaluated point with the commitment to the…",1,[[]]],[11,"flatten","","Flattens an `AggregateProof` into a `Proof`. The…",1,[[["transcript",3]],["proof",3]]],[11,"from_projective","","Builds a `Commitment` from a Bls12_381 `G1Projective` point.",2,[[["g1projective",3]]]],[11,"from_affine","","Builds a `Commitment` from a Bls12_381 `G1Affine` point.",2,[[["g1affine",3]]]],[11,"empty","","Builds an empty `Commitment` which is equivalent to the…",2,[[]]],[0,"constraint_system","dusk_plonk","The constraint System module stores the implementation of…",null,null],[3,"StandardComposer","dusk_plonk::constraint_system","A composer is a circuit builder and will dictate how a…",null,null],[3,"Variable","","The value is a reference to the actual value that was…",null,null],[4,"WireData","","Stores the data for a specific wire in an arithmetic…",null,null],[13,"Left","","Left Wire of n\'th gate",7,null],[13,"Right","","Right Wire of n\'th gate",7,null],[13,"Output","","Output Wire of n\'th gate",7,null],[13,"Fourth","","Fourth Wire of n\'th gate",7,null],[11,"circuit_size","","Returns the number of gates in the circuit",8,[[]]],[11,"new","","Generates a new empty `StandardComposer` with all of it\'s…",8,[[]]],[11,"with_expected_size","","Creates a new circuit with an expected circuit size. This…",8,[[]]],[11,"add_input","","Add Input first calls the `Permutation` struct to generate…",8,[[["scalar",3]],["variable",3]]],[11,"poly_gate","","Adds a width-3 poly gate. This gate gives total freedom to…",8,[[["variable",3],["scalar",3]]]],[11,"constrain_to_constant","","Adds a gate which is designed to constrain a `Variable` to…",8,[[["variable",3],["scalar",3]]]],[11,"assert_equal","","Asserts that two variables are the same",8,[[["variable",3]]]],[11,"add_dummy_constraints","","This function is used to add a blinding factor to the…",8,[[]]],[0,"arithmetic","","Simple Arithmetic gates",null,null],[11,"add_gate","","Adds a width-3 add gate to the circuit, linking the…",8,[[["variable",3],["scalar",3]],["variable",3]]],[11,"big_add_gate","","Adds a width-4 add gate to the circuit and it\'s…",8,[[["option",4],["variable",3],["scalar",3]],["variable",3]]],[11,"mul_gate","","Adds a width-3 add gate to the circuit linking the product…",8,[[["variable",3],["scalar",3]],["variable",3]]],[11,"big_mul_gate","","Adds a width-4 `big_mul_gate` with the left, right and…",8,[[["option",4],["variable",3],["scalar",3]],["variable",3]]],[11,"add","","Adds a `big_addition_gate` with the left and right inputs…",8,[[["scalar",3]],["variable",3]]],[11,"big_add","","Adds a `big_addition_gate` with the left, right and fourth…",8,[[["option",4],["scalar",3]],["variable",3]]],[11,"mul","","Adds a simple and basic addition to the circuit between to…",8,[[["scalar",3],["variable",3]],["variable",3]]],[11,"big_mul","","Adds a width-4 `big_mul_gate` with the left, right and…",8,[[["option",4],["scalar",3],["variable",3]],["variable",3]]],[0,"boolean","","Boolean gate",null,null],[11,"boolean_gate","","Adds a boolean constraint (also known as binary…",8,[[["variable",3]],["variable",3]]],[0,"logic","","XOR and AND gates",null,null],[11,"xor_gate","","Adds a logical XOR gate that performs the XOR between two…",8,[[["variable",3]],["variable",3]]],[11,"and_gate","","Adds a logical AND gate that performs the bitwise AND…",8,[[["variable",3]],["variable",3]]],[0,"range","","Range gate",null,null],[11,"range_gate","","Adds a range-constraint gate that checks and constrains a…",8,[[["variable",3]]]],[0,"fft","dusk_plonk","FFT module contains the tools needed by the Composer…",null,null],[3,"EvaluationDomain","dusk_plonk::fft","Defines a domain over which finite field (I)FFTs can be…",null,null],[12,"size","","The size of the domain.",9,null],[12,"log_size_of_group","","`log_2(self.size)`.",9,null],[12,"size_as_field_element","","Size of the domain as a field element.",9,null],[12,"size_inv","","Inverse of the size in the field.",9,null],[12,"group_gen","","A generator of the subgroup.",9,null],[12,"group_gen_inv","","Inverse of the generator of the subgroup.",9,null],[12,"generator_inv","","Multiplicative generator of the finite field.",9,null],[3,"Evaluations","","Stores a polynomial in evaluation form.",null,null],[12,"evals","","The evaluations of a polynomial over the domain `D`",10,null],[3,"Polynomial","","Polynomial represents a polynomial in coeffiient form.",null,null],[12,"coeffs","","The coefficient of `x^i` is stored at location `i` in…",11,null],[11,"new","","Construct a domain that is large enough for evaluations of…",9,[[],[["error",3],["result",4]]]],[11,"compute_size_of_domain","","Return the size of a domain that is large enough for…",9,[[],["option",4]]],[11,"size","","Return the size of `self`.",9,[[]]],[11,"fft","","Compute a FFT.",9,[[],[["vec",3],["scalar",3]]]],[11,"fft_in_place","","Compute a FFT, modifying the vector in place.",9,[[["vec",3]]]],[11,"ifft","","Compute an IFFT.",9,[[],[["vec",3],["scalar",3]]]],[11,"ifft_in_place","","Compute an IFFT, modifying the vector in place.",9,[[["vec",3]]]],[11,"coset_fft","","Compute a FFT over a coset of the domain.",9,[[],[["vec",3],["scalar",3]]]],[11,"coset_fft_in_place","","Compute a FFT over a coset of the domain, modifying the…",9,[[["vec",3]]]],[11,"coset_ifft","","Compute an IFFT over a coset of the domain.",9,[[],[["vec",3],["scalar",3]]]],[11,"coset_ifft_in_place","","Compute an IFFT over a coset of the domain, modifying the…",9,[[["vec",3]]]],[11,"evaluate_all_lagrange_coefficients","","Evaluate all the lagrange polynomials defined by this…",9,[[["scalar",3]],[["vec",3],["scalar",3]]]],[11,"evaluate_vanishing_polynomial","","This evaluates the vanishing polynomial for this domain at…",9,[[["scalar",3]],["scalar",3]]],[11,"compute_vanishing_poly_over_coset","","Given that the domain size is `D` This function computes…",9,[[],["evaluations",3]]],[11,"elements","","Return an iterator over the elements of the domain.",9,[[],["elements",3]]],[11,"divide_by_vanishing_poly_on_coset_in_place","","The target polynomial is the zero polynomial in our…",9,[[]]],[11,"reindex_by_subdomain","","Given an index which assumes the first elements of this…",9,[[]]],[11,"mul_polynomials_in_evaluation_domain","","Perform O(n) multiplication of two polynomials that are…",9,[[],[["vec",3],["scalar",3]]]],[11,"from_vec_and_domain","","Construct `Self` from evaluations and a domain.",10,[[["evaluationdomain",3],["vec",3],["scalar",3]]]],[11,"interpolate_by_ref","","Interpolate a polynomial from a list of evaluations",10,[[],["polynomial",3]]],[11,"interpolate","","Interpolate a polynomial from a list of evaluations",10,[[],["polynomial",3]]],[11,"zero","","Returns the zero polynomial.",11,[[]]],[11,"is_zero","","Checks if the given polynomial is zero.",11,[[]]],[11,"from_coefficients_slice","","Constructs a new polynomial from a list of coefficients.",11,[[]]],[11,"from_coefficients_vec","","Constructs a new polynomial from a list of coefficients.",11,[[["vec",3],["scalar",3]]]],[11,"degree","","Returns the degree of the polynomial.",11,[[]]],[11,"evaluate","","Evaluates `self` at the given `point` in the field.",11,[[["scalar",3]],["scalar",3]]],[11,"rand","","Outputs a polynomial of degree `d` where each coefficient…",11,[[]]],[11,"ruffini","","Divides `self` by x-z using Ruffinis method",11,[[["scalar",3]],["polynomial",3]]],[0,"prelude","dusk_plonk","Collection of functions needed to use plonk library.",null,null],[3,"Scalar","dusk_plonk::prelude","Represents an element of the scalar field $\\\\mathbb{F}_q$…",null,null],[12,"0","","",12,null],[3,"StandardComposer","","A composer is a circuit builder and will dictate how a…",null,null],[3,"Variable","","The value is a reference to the actual value that was…",null,null],[3,"ProverKey","","PLONK circuit proving key",null,null],[12,"arithmetic","","ProverKey for arithmetic gate",13,null],[12,"logic","","ProverKey for logic gate",13,null],[12,"range","","ProverKey for range gate",13,null],[12,"permutation","","ProverKey for permutation checks",13,null],[3,"VerifierKey","","PLONK circuit verification key",null,null],[12,"n","","Circuit size",14,null],[12,"arithmetic","","VerifierKey for arithmetic gates",14,null],[12,"logic","","VerifierKey for logic gates",14,null],[12,"range","","VerifierKey for range gates",14,null],[12,"permutation","","VerifierKey for permutation checks",14,null],[0,"plonk_errors","","Collection of errors that the library exposes/uses.",null,null],[3,"ProvingError","dusk_plonk::prelude::plonk_errors","Represents an error on the Proving stage.",null,null],[3,"FFTError","","Represents an error triggered on any of the FFT module…",null,null],[3,"ProofError","","Represents an error triggered on any of the proof_system…",null,null],[4,"PreProcessingError","","Represents an error on the Circuit preprocessing stage.",null,null],[13,"MissmatchedPolyLen","","This error occurs when an error triggers during the…",15,null],[4,"FFTErrors","","Defines all of the possible FFTError types that we could…",null,null],[13,"InvalidEvalDomainSize","","This error occurs when an error triggers on any of the fft…",16,null],[12,"log_size_of_group","dusk_plonk::prelude::plonk_errors::FFTErrors","Log size of the group",17,null],[12,"adacity","","Two adacity generated",17,null],[4,"ProofErrors","dusk_plonk::prelude::plonk_errors","Defines all of the possible ProofError types that we could…",null,null],[13,"ProofVerificationError","","This error occurs when the verification of a `Proof` fails.",18,null],[13,"CircuitAlreadyPreprocessed","","This error occurrs when the Prover structure already…",18,null],[0,"proof_system","dusk_plonk","proving system",null,null],[11,"preprocess_prover","dusk_plonk::constraint_system","These are the parts of preprocessing that the prover must…",8,[[["transcript",3],["commitkey",3]],[["error",3],["proverkey",3],["result",4]]]],[11,"preprocess_verifier","","The verifier only requires the commitments in order to…",8,[[["transcript",3],["commitkey",3]],[["result",4],["error",3],["verifierkey",3]]]],[0,"proof","dusk_plonk::proof_system","Represents a PLONK Proof A Proof stores the commitments to…",null,null],[3,"Proof","dusk_plonk::proof_system::proof","A Proof is a composition of `Commitments` to the witness,…",null,null],[12,"a_comm","","Commitment to the witness polynomial for the left wires.",19,null],[12,"b_comm","","Commitment to the witness polynomial for the right wires.",19,null],[12,"c_comm","","Commitment to the witness polynomial for the output wires.",19,null],[12,"d_comm","","Commitment to the witness polynomial for the fourth wires.",19,null],[12,"z_comm","","Commitment to the permutation polynomial.",19,null],[12,"t_1_comm","","Commitment to the quotient polynomial.",19,null],[12,"t_2_comm","","Commitment to the quotient polynomial.",19,null],[12,"t_3_comm","","Commitment to the quotient polynomial.",19,null],[12,"t_4_comm","","Commitment to the quotient polynomial.",19,null],[12,"w_z_comm","","Commitment to the opening polynomial.",19,null],[12,"w_zw_comm","","Commitment to the shifted opening polynomial.",19,null],[12,"evaluations","","Subset of all of the evaluations added to the proof.",19,null],[11,"verify","","Performs the verification of a `Proof` returning a boolean…",19,[[["verifierkey",3],["openingkey",3],["transcript",3]],[["result",4],["error",3]]]],[0,"prover","dusk_plonk::proof_system","Represents a PLONK Prover",null,null],[3,"Prover","dusk_plonk::proof_system::prover","Prover composes a circuit and builds a proof",null,null],[12,"prover_key","","ProverKey which is used to create proofs about a specific…",20,null],[12,"preprocessed_transcript","","Store the messages exchanged during the preprocessing…",20,null],[11,"mut_cs","","Returns a mutable copy of the underlying composer",20,[[],["standardcomposer",3]]],[11,"preprocess","","Preprocesses the underlying constraint system",20,[[["commitkey",3]],[["result",4],["error",3]]]],[11,"new","","Creates a new prover object",20,[[],["prover",3]]],[11,"circuit_size","","Returns the number of gates in the circuit",20,[[]]],[11,"clear_witness","","Resets the witnesses in the prover object. This function…",20,[[]]],[11,"clear","","Clears all data in the Prover This function is used when…",20,[[]]],[11,"key_transcript","","Keys the transcript with additional seed information…",20,[[]]],[11,"prove_with_preprocessed","","Creates a Proof that a circuit is satisfied Note that if…",20,[[["proverkey",3],["commitkey",3]],[["result",4],["error",3],["proof",3]]]],[11,"prove","","Proves a circuit is satisfied, then clears the witness…",20,[[["commitkey",3]],[["result",4],["error",3],["proof",3]]]],[0,"verifier","dusk_plonk::proof_system","Represents a PLONK Verifier",null,null],[3,"Verifier","dusk_plonk::proof_system::verifier","Verifier verifies a proof",null,null],[12,"verifier_key","","VerificationKey which is used to verify a specific PLONK…",21,null],[12,"preprocessed_transcript","","Store the messages exchanged during the preprocessing…",21,null],[11,"new","","Creates a new verifier object",21,[[],["verifier",3]]],[11,"circuit_size","","Returns the number of gates in the circuit",21,[[]]],[11,"mut_cs","","Returns a mutable copy of the underlying composer",21,[[],["standardcomposer",3]]],[11,"preprocess","","Preprocess a proof",21,[[["commitkey",3]],[["result",4],["error",3]]]],[11,"key_transcript","","Keys the transcript with additional seed information…",21,[[]]],[11,"verify","","Verifies a proof",21,[[["openingkey",3],["proof",3]],[["result",4],["error",3]]]],[0,"transcript","dusk_plonk","This is an extension over the Merlin Transcript which adds…",null,null],[8,"TranscriptProtocol","dusk_plonk::transcript","Transcript adds an abstraction over the Merlin transcript…",null,null],[10,"append_commitment","","Append a `commitment` with the given `label`.",22,[[["commitment",3]]]],[10,"append_scalar","","Append a `Scalar` with the given `label`.",22,[[["scalar",3]]]],[10,"challenge_scalar","","Compute a `label`ed challenge variable.",22,[[],["scalar",3]]],[10,"circuit_domain_sep","","Append domain separator for the circuit size.",22,[[]]],[0,"notes","dusk_plonk","This module is a self contained file which explains how…",null,null],[0,"commitment_schemes","dusk_plonk::notes","This module explains the inner workings of commitment…",null,null],[0,"permutation_arguments","","Contained within this module are the notes on how the…",null,null],[0,"snark_construction","","This module contains the methodology of how zk-SNARKS are…",null,null],[0,"prove_verify","","This module contains the notes on how the prover algorithm…",null,null],[0,"unbalanced_perm_args","","Contained within this module are the notes on how the…",null,null],[0,"kzg10_docs","","In this module we show how and why the KZG10 polynomial…",null,null],[11,"from","dusk_plonk::commitment_scheme::kzg10","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"vzip","","",0,[[]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"vzip","","",1,[[]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"vzip","","",2,[[]]],[11,"from","dusk_plonk::commitment_scheme::kzg10::errors","",23,[[]]],[11,"into","","",23,[[]]],[11,"to_string","","",23,[[],["string",3]]],[11,"try_from","","",23,[[],["result",4]]],[11,"try_into","","",23,[[],["result",4]]],[11,"borrow","","",23,[[]]],[11,"borrow_mut","","",23,[[]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"as_fail","","",23,[[],["fail",8]]],[11,"vzip","","",23,[[]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"to_string","","",3,[[],["string",3]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"as_fail","","",3,[[],["fail",8]]],[11,"vzip","","",3,[[]]],[11,"from","dusk_plonk::commitment_scheme::kzg10::key","",4,[[]]],[11,"into","","",4,[[]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"vzip","","",4,[[]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"vzip","","",5,[[]]],[11,"from","dusk_plonk::commitment_scheme::kzg10::srs","",6,[[]]],[11,"into","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"vzip","","",6,[[]]],[11,"from","dusk_plonk::constraint_system","",8,[[]]],[11,"into","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"vzip","","",8,[[]]],[11,"from","","",24,[[]]],[11,"into","","",24,[[]]],[11,"to_owned","","",24,[[]]],[11,"clone_into","","",24,[[]]],[11,"try_from","","",24,[[],["result",4]]],[11,"try_into","","",24,[[],["result",4]]],[11,"borrow","","",24,[[]]],[11,"borrow_mut","","",24,[[]]],[11,"type_id","","",24,[[],["typeid",3]]],[11,"vzip","","",24,[[]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"to_owned","","",7,[[]]],[11,"clone_into","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"vzip","","",7,[[]]],[11,"from","dusk_plonk::prelude::plonk_errors","",25,[[]]],[11,"into","","",25,[[]]],[11,"to_string","","",25,[[],["string",3]]],[11,"try_from","","",25,[[],["result",4]]],[11,"try_into","","",25,[[],["result",4]]],[11,"borrow","","",25,[[]]],[11,"borrow_mut","","",25,[[]]],[11,"type_id","","",25,[[],["typeid",3]]],[11,"as_fail","","",25,[[],["fail",8]]],[11,"vzip","","",25,[[]]],[11,"from","","",15,[[]]],[11,"into","","",15,[[]]],[11,"to_string","","",15,[[],["string",3]]],[11,"try_from","","",15,[[],["result",4]]],[11,"try_into","","",15,[[],["result",4]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"as_fail","","",15,[[],["fail",8]]],[11,"vzip","","",15,[[]]],[11,"from","dusk_plonk::fft","",9,[[]]],[11,"into","","",9,[[]]],[11,"to_owned","","",9,[[]]],[11,"clone_into","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"vzip","","",9,[[]]],[11,"from","","",10,[[]]],[11,"into","","",10,[[]]],[11,"to_owned","","",10,[[]]],[11,"clone_into","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"vzip","","",10,[[]]],[11,"from","","",11,[[]]],[11,"into","","",11,[[]]],[11,"to_owned","","",11,[[]]],[11,"clone_into","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"try_into","","",11,[[],["result",4]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"vzip","","",11,[[]]],[11,"from","dusk_plonk::prelude::plonk_errors","",26,[[]]],[11,"into","","",26,[[]]],[11,"to_string","","",26,[[],["string",3]]],[11,"try_from","","",26,[[],["result",4]]],[11,"try_into","","",26,[[],["result",4]]],[11,"borrow","","",26,[[]]],[11,"borrow_mut","","",26,[[]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"as_fail","","",26,[[],["fail",8]]],[11,"vzip","","",26,[[]]],[11,"from","","",16,[[]]],[11,"into","","",16,[[]]],[11,"to_string","","",16,[[],["string",3]]],[11,"try_from","","",16,[[],["result",4]]],[11,"try_into","","",16,[[],["result",4]]],[11,"borrow","","",16,[[]]],[11,"borrow_mut","","",16,[[]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"as_fail","","",16,[[],["fail",8]]],[11,"vzip","","",16,[[]]],[11,"from","dusk_plonk::prelude","",12,[[]]],[11,"into","","",12,[[]]],[11,"to_owned","","",12,[[]]],[11,"clone_into","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"try_into","","",12,[[],["result",4]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"vzip","","",12,[[]]],[11,"conditional_negate","","",12,[[["choice",3]]]],[11,"from","","",13,[[]]],[11,"into","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"vzip","","",13,[[]]],[11,"from","","",14,[[]]],[11,"into","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"try_into","","",14,[[],["result",4]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"vzip","","",14,[[]]],[11,"from","dusk_plonk::prelude::plonk_errors","",27,[[]]],[11,"into","","",27,[[]]],[11,"to_string","","",27,[[],["string",3]]],[11,"try_from","","",27,[[],["result",4]]],[11,"try_into","","",27,[[],["result",4]]],[11,"borrow","","",27,[[]]],[11,"borrow_mut","","",27,[[]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"as_fail","","",27,[[],["fail",8]]],[11,"vzip","","",27,[[]]],[11,"from","","",18,[[]]],[11,"into","","",18,[[]]],[11,"to_string","","",18,[[],["string",3]]],[11,"try_from","","",18,[[],["result",4]]],[11,"try_into","","",18,[[],["result",4]]],[11,"borrow","","",18,[[]]],[11,"borrow_mut","","",18,[[]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"as_fail","","",18,[[],["fail",8]]],[11,"vzip","","",18,[[]]],[11,"from","dusk_plonk::proof_system::proof","",19,[[]]],[11,"into","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"try_into","","",19,[[],["result",4]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"vzip","","",19,[[]]],[11,"from","dusk_plonk::proof_system::prover","",20,[[]]],[11,"into","","",20,[[]]],[11,"try_from","","",20,[[],["result",4]]],[11,"try_into","","",20,[[],["result",4]]],[11,"borrow","","",20,[[]]],[11,"borrow_mut","","",20,[[]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"vzip","","",20,[[]]],[11,"from","dusk_plonk::proof_system::verifier","",21,[[]]],[11,"into","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"try_into","","",21,[[],["result",4]]],[11,"borrow","","",21,[[]]],[11,"borrow_mut","","",21,[[]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"vzip","","",21,[[]]],[11,"mul","dusk_plonk::prelude","",12,[[["scalar",3]],["scalar",3]]],[11,"mul","","",12,[[["scalar",3]],["scalar",3]]],[11,"cmp","","",12,[[["scalar",3]],["ordering",4]]],[11,"add_assign","","",12,[[["scalar",3]]]],[11,"add_assign","","",12,[[["scalar",3]]]],[11,"neg","","",12,[[],["scalar",3]]],[11,"eq","","",12,[[["scalar",3]]]],[11,"default","","",12,[[],["scalar",3]]],[11,"mul_assign","","",12,[[["scalar",3]]]],[11,"mul_assign","","",12,[[["scalar",3]]]],[11,"partial_cmp","","",12,[[["scalar",3]],[["ordering",4],["option",4]]]],[11,"sum","","",12,[[],["scalar",3]]],[11,"sub_assign","","",12,[[["scalar",3]]]],[11,"sub_assign","","",12,[[["scalar",3]]]],[11,"bitand","","",12,[[["scalar",3]],["scalar",3]]],[11,"from","","",12,[[],["scalar",3]]],[11,"clone","","",12,[[],["scalar",3]]],[11,"deserialize","","",12,[[],[["result",4],["scalar",3]]]],[11,"add","","",12,[[["scalar",3]],["scalar",3]]],[11,"add","","",12,[[["scalar",3]],["scalar",3]]],[11,"sub","","",12,[[["scalar",3]],["scalar",3]]],[11,"sub","","",12,[[["scalar",3]],["scalar",3]]],[11,"product","","",12,[[],["scalar",3]]],[11,"fmt","","",12,[[["formatter",3]],[["error",3],["result",4]]]],[11,"serialize","","",12,[[],["result",4]]],[11,"bitxor","","",12,[[["scalar",3]],["scalar",3]]],[11,"ct_eq","","",12,[[["scalar",3]],["choice",3]]],[11,"conditional_select","","",12,[[["scalar",3],["choice",3]],["scalar",3]]],[11,"into","dusk_plonk::constraint_system","",24,[[]]],[11,"clone","dusk_plonk::commitment_scheme::kzg10::key","",4,[[],["openingkey",3]]],[11,"clone","dusk_plonk::commitment_scheme::kzg10","",0,[[],["proof",3]]],[11,"clone","","",2,[[],["commitment",3]]],[11,"clone","dusk_plonk::constraint_system","",24,[[],["variable",3]]],[11,"clone","","",7,[[],["wiredata",4]]],[11,"clone","dusk_plonk::fft","",9,[[],["evaluationdomain",3]]],[11,"clone","","",10,[[],["evaluations",3]]],[11,"clone","","",11,[[],["polynomial",3]]],[11,"default","dusk_plonk::commitment_scheme::kzg10","",2,[[]]],[11,"default","dusk_plonk::constraint_system","",8,[[]]],[11,"default","dusk_plonk::proof_system::prover","",20,[[],["prover",3]]],[11,"default","dusk_plonk::proof_system::verifier","",21,[[],["verifier",3]]],[11,"eq","dusk_plonk::commitment_scheme::kzg10","",2,[[["commitment",3]]]],[11,"ne","","",2,[[["commitment",3]]]],[11,"eq","dusk_plonk::constraint_system","",24,[[["variable",3]]]],[11,"ne","","",24,[[["variable",3]]]],[11,"eq","","",7,[[["wiredata",4]]]],[11,"ne","","",7,[[["wiredata",4]]]],[11,"eq","dusk_plonk::fft","",9,[[["evaluationdomain",3]]]],[11,"ne","","",9,[[["evaluationdomain",3]]]],[11,"eq","","",10,[[["evaluations",3]]]],[11,"ne","","",10,[[["evaluations",3]]]],[11,"eq","","",11,[[["polynomial",3]]]],[11,"ne","","",11,[[["polynomial",3]]]],[11,"eq","dusk_plonk::proof_system::proof","",19,[[["proof",3]]]],[11,"ne","","",19,[[["proof",3]]]],[11,"deref","dusk_plonk::fft","",11,[[]]],[11,"deref_mut","","",11,[[]]],[11,"fmt","dusk_plonk::commitment_scheme::kzg10::errors","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",23,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::commitment_scheme::kzg10::key","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::commitment_scheme::kzg10::srs","",6,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::commitment_scheme::kzg10","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::constraint_system","",8,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::prelude::plonk_errors","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",25,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::constraint_system","",24,[[["formatter",3]],["result",6]]],[11,"fmt","","",7,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::fft","",9,[[["formatter",3]],["result",6]]],[11,"fmt","","",10,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::prelude::plonk_errors","",16,[[["formatter",3]],["result",6]]],[11,"fmt","","",26,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::fft","",11,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::proof_system::proof","",19,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::prelude::plonk_errors","",18,[[["formatter",3]],["result",6]]],[11,"fmt","","",27,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::prelude","",13,[[["formatter",3]],["result",6]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::commitment_scheme::kzg10::errors","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",23,[[["formatter",3]],["result",6]]],[11,"fmt","dusk_plonk::prelude::plonk_errors","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",25,[[["formatter",3]],["result",6]]],[11,"fmt","","",16,[[["formatter",3]],["result",6]]],[11,"fmt","","",26,[[["formatter",3]],["result",6]]],[11,"fmt","","",18,[[["formatter",3]],["result",6]]],[11,"fmt","","",27,[[["formatter",3]],["result",6]]],[11,"neg","dusk_plonk::fft","",11,[[],["polynomial",3]]],[11,"add_assign","","",10,[[["evaluations",3]]]],[11,"add_assign","","",11,[[["polynomial",3]]]],[11,"add_assign","","",11,[[]]],[11,"sub_assign","","",10,[[["evaluations",3]]]],[11,"sub_assign","","",11,[[["polynomial",3]]]],[11,"mul_assign","","",10,[[["evaluations",3]]]],[11,"div_assign","","",10,[[["evaluations",3]]]],[11,"index","","",10,[[],["scalar",3]]],[11,"hash","dusk_plonk::constraint_system","",24,[[]]],[11,"sum","dusk_plonk::fft","",11,[[]]],[11,"name","dusk_plonk::commitment_scheme::kzg10::errors","",3,[[],["option",4]]],[11,"cause","","",3,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",3,[[],[["option",4],["backtrace",3]]]],[11,"name","","",23,[[],["option",4]]],[11,"cause","","",23,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",23,[[],[["option",4],["backtrace",3]]]],[11,"name","dusk_plonk::prelude::plonk_errors","",15,[[],["option",4]]],[11,"cause","","",15,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",15,[[],[["option",4],["backtrace",3]]]],[11,"name","","",25,[[],["option",4]]],[11,"cause","","",25,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",25,[[],[["option",4],["backtrace",3]]]],[11,"name","","",16,[[],["option",4]]],[11,"cause","","",16,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",16,[[],[["option",4],["backtrace",3]]]],[11,"name","","",26,[[],["option",4]]],[11,"cause","","",26,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",26,[[],[["option",4],["backtrace",3]]]],[11,"name","","",18,[[],["option",4]]],[11,"cause","","",18,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",18,[[],[["option",4],["backtrace",3]]]],[11,"name","","",27,[[],["option",4]]],[11,"cause","","",27,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",27,[[],[["option",4],["backtrace",3]]]],[11,"zero","dusk_plonk::prelude","Returns zero, the additive identity.",12,[[],["scalar",3]]],[11,"one","","Returns one, the multiplicative identity.",12,[[],["scalar",3]]],[11,"internal_repr","","Returns the internal representation of the Scalar.",12,[[]]],[11,"double","","Doubles this field element.",12,[[],["scalar",3]]],[11,"from_bytes","","Attempts to convert a little-endian byte representation of…",12,[[],[["scalar",3],["ctoption",3]]]],[11,"to_bytes","","Converts an element of `Scalar` into a byte representation…",12,[[]]],[11,"from_bytes_wide","","Converts a 512-bit little endian integer into a `Scalar`…",12,[[],["scalar",3]]],[11,"from_raw","","Converts from an integer represented in little endian into…",12,[[],["scalar",3]]],[11,"random","","Generate a valid Scalar choosen uniformly using user-…",12,[[],["scalar",3]]],[11,"reduce","","Reduces the scalar and returns it multiplied by the…",12,[[],["scalar",3]]],[11,"square","","Squares this element.",12,[[],["scalar",3]]],[11,"sqrt","","Computes the square root of this element, if it exists.",12,[[],[["scalar",3],["ctoption",3]]]],[11,"pow","","Exponentiates `self` by `by`, where `by` is a…",12,[[],["scalar",3]]],[11,"pow_vartime","","Exponentiates `self` by `by`, where `by` is a…",12,[[],["scalar",3]]],[11,"invert","","Computes the multiplicative inverse of this element,…",12,[[],[["scalar",3],["ctoption",3]]]],[11,"mul","","Multiplies `rhs` by `self`, returning the result.",12,[[["scalar",3]],["scalar",3]]],[11,"sub","","Subtracts `rhs` from `self`, returning the result.",12,[[["scalar",3]],["scalar",3]]],[11,"add","","Adds `rhs` to `self`, returning the result.",12,[[["scalar",3]],["scalar",3]]],[11,"neg","","Negates `self`.",12,[[],["scalar",3]]],[11,"divn","","SHR impl",12,[[]]]],"p":[[3,"Proof"],[3,"AggregateProof"],[3,"Commitment"],[4,"KZG10Errors"],[3,"OpeningKey"],[3,"CommitKey"],[3,"PublicParameters"],[4,"WireData"],[3,"StandardComposer"],[3,"EvaluationDomain"],[3,"Evaluations"],[3,"Polynomial"],[3,"Scalar"],[3,"ProverKey"],[3,"VerifierKey"],[4,"PreProcessingError"],[4,"FFTErrors"],[13,"InvalidEvalDomainSize"],[4,"ProofErrors"],[3,"Proof"],[3,"Prover"],[3,"Verifier"],[8,"TranscriptProtocol"],[3,"PolyCommitSchemeError"],[3,"Variable"],[3,"ProvingError"],[3,"FFTError"],[3,"ProofError"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);